# C++必知必会——自动类型推导

1. 自动类型推导：一些局限性

    1. ```auto``` 需要等号右边的类型信息，故不可以单独声明一个```auto```变量；

    2. 类成员也不可以定义为```auto``。

2. 自动类型推导：函数返回值

    使用 ```auto``` 以后，会自动被推导为 ```return``` 右边的类型。

    不过也有三点注意事项：

    1. 当函数有多条 ```return``` 语句时，所有语句的返回类型必须一致，否则 ```auto``` 会报错。
    2. 当函数没有 ```return``` 语句时，```auto``` 会被推导为 ```void```。
    3. 如果声明和实现分离了，则不能声明为 ```auto```。比如：```auto func(); // 错误```

3. 自动类型推导：引用、常量引用、函数返回引用

    ```C++
    auto &ref = x;
    auto const &ref = x;
    auto &func(){ ... }
    ```

4. 自动类型推导：万能引用

    如果一个表达式，我不知道他是个可变引用（int &），常引用（int const &），右值引用（int &&），还是一个普通的值（int）。

    但我就是想要定义一个和表达式返回类型一样的变量，这时候可以用：

    ```C++
    decltype(auto) p = func();
    ```

    会自动推导为 func() 的返回类型。和下面这种方式等价：

    ```C++
    decltype(func()) p = func();
    ```

    在代理模式中，用于完美转发函数返回值。比如：

    ```C++
    decltype(auto) at(size_t i) const {
    return m_internal_class.at(i);
    }
    ```

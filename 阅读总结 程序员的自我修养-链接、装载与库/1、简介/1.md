# 1. 简介

## 1.1 从 Hello World 开始

```c++
#include <stdio.h>

int main() {
    printf("Hello World!\n");
    return 0;
}
```

- 程序为什么要被编译器编译了之后才可以运行呢？
- 编译器在把 C 语言程序转换成可以执行的机器码的过程中做了什么，怎么做的？
- 最后编译出来的可执行文件里面是什么？除了机器码还有什么？它们怎么存放的，怎么组织的？
- #include <stdio.h> 是什么意思？把其包含进来意味着什么？C 语言库又是什么？它怎么实现的？
- 不同的编译器（Microsoft VC、GCC）和不同的硬件平台（X86、SPARC、MIPS、ARM），以及不同的操作系统（Windows、Linux、Unix、Solaris），最终编译出来的结果一样吗？为什么？
- Hello World 程序是怎么运行起来的？操作系统是怎么装载它的？它是从哪儿开始执行，到哪儿结束？main 函数之前发生了什么？main 函数结束以后又发生了什么？
- 如果没有操作系统，Hello World 可以运行吗？如果要在一台没有操作系统的机器上运行 Hello World 需要什么？应该怎么实现？
- printf 是怎么实现的？它为什么可以有不定数量的参数？为什么它能够在终端上输出字符串？
- Hello World 程序在运行时，它在内存中是什么样子的？

## 1.2 万变不离其宗

计算机的核心部件：中央处理器CPU、内存和I/O控制芯片。

早期的计算机没有很复杂的图形功能，CPU 的核心频率也不高，跟内存的频率一样，它们都是之间连接在同一个**总线**（**Bus**）上的。由于 I/O 设备诸如显示设备、键盘、软盘和磁盘等速度与 CPU 相比还是慢很多，当时也没有复杂的图像设备，显示设备大多是只能输出字符的终端。为了协调I/O设备和与总线之间的速度，也为了能够让 CPU 能够和 I/O 设备进行通信，一般每个设备都会有一个相应的I/O控制器。

![alt text](<./figs/Screenshot from 2024-09-22 22-38-53.png> "早期计算机")

后来由于 CPU 核心频率的提升，导致内存跟不上 CPU 的速度，于是产生了与内存频率一致的系统总线，而 CPU 采用倍频的方式与系统总线进行通信。接着随着图像化的操作系统普及，特别是 3D 游戏和多媒体的发展，是的图形芯片需要跟 CPU 和内存之间大量交换数据，慢速的 I/O 总线已经无法满足图形设备的巨大需求。为了协调 CPU、内存和高速的图像设备，人们专门设计了一个高速的北桥芯片，以便它们之间能够高速地交换数据。

由于北桥运行的速度非常高，所有相对低速的设备如果全部直接连接在北桥上，北桥既需处理高速设备，又须处理低速设备，设计就会十分复杂。于是人们又设计了专门处理低速设备的**南桥**（**South Bridge**）芯片，磁盘、USB、键盘、鼠标等设备都连接在南桥上，由南桥将它们汇总后连接到北桥上。20 世纪 90 年代的 PC 机在系统总线上采用的是 PCI 结构，而在低速设备上采用的 ISA 总线，采用 PCI/ISA 及南北桥设计的硬件架构如下图所示。

![alt text](<./figs/Screenshot from 2024-09-22 22-53-39.png> "PC 机硬件架构")

位于中间是连接所有高速芯片的**北桥**（**North Bridge, PCI Bridge**），它就像人的心脏，连接并驱动身体的各个部位；它的左边是 CPU，负责所有的控制和运算，就像人的大脑。北桥还还连接这几个高速部件，包括左边的内存和下面的 PCI 总线。

PCI 的速度最高为 133 MHz，它还是不能满足人们的需求，于是人们又发明了 AGP、PCI Express 等高速总线，它们的速度都超过 133 MHz，但仍然不能满足人们的需求。于是又发明了 PCI-X、PCI-E 等扩展总线，它们的速度更快，但仍然不能满足人们的需求。于是又发明了 PCI-E 4.0 标准，它将 PCI-E 总线的宽度扩展到了 128 位，可以同时连接 8 个设备，这样就可以满足人们对高速设备的需求。

### SMP与多核

人们总是希望计算机越来越快。在过去的 50 年里，CPU 的频率从 几十 KHz 到现在的 4 GHz，整整提高了数十万倍，基本上每 18 个月频率就会翻倍。但是自 2004 年以来，这种规律似乎已经失效，CPU 的频率自从那时开始再也没有发生质的提高。原因是人们在制造 CPU 的工艺方面已经达到了物理极限，除非 CPU 制造工艺有本质的突破，否则 CPU 的频率将会一直被目前 4 GHz 的“天花板”所限制。

在频率上短期内已经没有提高的余地，于是人们开始想办法从另一个角度来提高 CPU 的速度，就是增加 CPU 的数量。一个计算机拥有多个 CPU 早就不是什么新鲜事了，很早以前就有了多 CPU 的计算机，其中最常见的一种形式就是**对称多处理器**（**Symmetric Multi-Processing, SMP**），简单地讲就是每个 CPU 在系统中所处的地位和所发挥的功能都是一样的，都是相互对称的。理论上讲，增加 CPU 的数量就可以提高运算速度，并且理想情况下，速度的提高与 CPU 的数量成正比。但实际上并非如此，因为我们的程序并不是都能分解成若干个完全不相干的子问题。

当然很多时候多处理器是非常有用的，最常见的情况就是在大型的数据库、网络服务器上，它们要同时处理大量的请求，而这些请求之间往往是相互独立的，所以多处理器就可以最大效能地发挥威力。

考虑到多处理器的成本较高，处理器的厂商开始考虑将多个处理器“合并在一起打包出售”，这些“被打包”的处理器之间共享比较昂贵的缓存部件，只保留多个核心，并且以一个处理器的外包装进行出售，售价比单核心的处理器只贵了一点，这就是**多核处理器**（**Multi-Core Processing, MPP**）的基本想法。多核处理器实际上就是 **SMP** 的简化版，当然它们在细节上还有一些差别，但从程序员的角度来看，它们之间的区别很小，逻辑上来看它们是完全相同的。只是多核和 **SMP** 在缓存共享等方面有细微的差别，使得程序在优化上可以有针对性地处理。简单地讲，除非想把 **CPU** 的每一第油水都榨干，否则可以把多核和 **SMP** 看成同一个概念。


## 1.3 站得高，看得远

系统软件这个概念是比较模糊的，传统意义上一般将用于管理计算机本身的软件称为系统软件，以区别普通的应用程序。系统软件可以分成两块：

- 平台性的，比如操作系统、驱动程序、运行库和数以千计的系统工具；
- 用于程序开发的，比如编译器、汇编器、链接器等开发工具和开发库。*

**“计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决”**

上面这句话几乎概括了计算机系统软件体系结构的设计要点，整个体系结构从上到下都是按照严格的层次结构设计的。不仅是计算机系统软件整个体系都是这样的，体系里面的每个组件比如操作系统本身，很多应用程序、软件系统甚至很多硬件结构都是按照这种层次的将诶沟组织和设计的。

![alt text](<./figs/Screenshot from 2024-09-24 22-07-34.png> "计算机软件体系结构")

每个层次之间都需要相互通信，既然需要通信就必须有一个通信的协议，我们一般将其称之为**接口**（**Interface**），接口的下面那层是接口的提供者，由它定义接口；接口的上面那层是接口的使用者，它使用该接口来实现所需要的功能。在层次体系中，接口是被精心设计过的，尽量保持稳定不便，那么理论上层次之间只要遵循这个接口，任何一个层都可以被修改或替换。除了硬件和应用程序，其他都是所谓的中间层，每个中间层都是对它下面的那个层次的包装和扩展。正是这些中间层的存在，是的应用程序和硬件之间保持相对的独立，比如硬件和操作系统都日新月异地发展，但是最初为 8086 芯片和 **DOS** 系统设计的软件在最新的多核处理器和 **Windows Vista** 下还是能够运行的，这方面归功于硬件和操作系统本身保持了向后兼容性，另一方面不得不归功于这种层次结构的设计方式。最近开始流行的虚拟机技术更是在硬件和操作系统之间增加了一层虚拟层，使得一个计算机上可以同时运行多个操作系统，这也是层次结构带来的好处，在尽可能少改变甚至不改变其他层的情况下，新增加一个层次就可以提供前所未有的功能。

我们的软件体系中，位于最上层的是应用程序，比如我们平时用到的网络浏览器等。从整个层次结构上看，开发工具与应用程序是属于同一个层次的，因为它们都使用同一个接口，那就是操作系统**应用程序编程接口**（**Application Programming Interface, API**）。应用程序接口的提供者是运行库，什么样的运行库提供什么样的 **API**，比如 Linux 下的 Glibc 提供 POSIX 的 **API**，Windows 下的运行库提供 Windows API，最常见的 32 位 Windows 提供的 **API** 又被称为 Win32 API。

运行库使用操作系统提供的**系统调用接口**（System Call Interface, **Syscall**），系统调用接口在实现中往往以**软件中断**（**Software Interrupt**）的方式提供，比如 Linux 使用 ```0x80``` 号中断作为系统调用接口，Windows 使用 ```0x2E``` 号中断作为系统调用接口（从 Windows XP Sp2开始，Windows 开始采用一种新的系统调用方式）。

操作系统内核层对于硬件层来说是硬件接口的使用者，而硬件是接口的定义者，硬件的接口定义决定了操作系统内核，具体来讲就是驱动程序如何操作硬件，如何与硬件进行通信。这种接口往往被叫做**硬件规格**（**Hardware Specification**），硬件的生产厂商负责提供硬件规格，操作系统和驱动程序的开发者通过阅读硬件规格文档所规定的各种硬件编程接口标准来编写操作系统和驱动程序。